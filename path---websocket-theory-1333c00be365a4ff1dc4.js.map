{"version":3,"sources":["webpack:///path---websocket-theory-1333c00be365a4ff1dc4.js","webpack:///./.cache/json/websocket-theory.json"],"names":["webpackJsonp","556","module","exports","data","site","siteMetadata","title","author","markdownRemark","id","html","frontmatter","date","pathContext","slug","previous","fields","next"],"mappings":"AAAAA,cAAc,gBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,uBAAAC,OAAA,kBAAyDC,gBAAmBC,GAAA,oIAAAC,KAAA,2vLAAAC,aAA0kML,MAAA,eAAAM,KAAA,kBAA+CC,aAAgBC,KAAA,qBAAAC,UAAwCC,QAAUF,KAAA,8BAAoCH,aAAgBL,MAAA,yCAAgDW,MAASD,QAAUF,KAAA,uBAA6BH,aAAgBL,MAAA","file":"path---websocket-theory-1333c00be365a4ff1dc4.js","sourcesContent":["webpackJsonp([8617267641406],{\n\n/***/ 556:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Blog - Jianhua Cheng\",\"author\":\"Jianhua Cheng\"}},\"markdownRemark\":{\"id\":\"/Users/chengjianhua/Documents/codes/chengjianhua.github.io/src/pages/websocket-theory/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<h2 id=\\\"背景\\\"><a href=\\\"#%E8%83%8C%E6%99%AF\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>背景</h2>\\n<p>以前的网站为了实现<strong>推送</strong>功能，使用的方法都是<strong>轮询</strong>。所谓的轮询就是在特定的时间间隔（例如 1 秒），由浏览器向服务器发出一个 <code class=\\\"language-text\\\">Http request</code>，然后服务器返回最新的数据给客户端浏览器，从而给出一种服务端实时推送的假象。由于<code class=\\\"language-text\\\">Http Request</code>的<code class=\\\"language-text\\\">Header</code>（请求头）很长,而传输的数据可能很短就只占一点点，每次请求消耗的带宽大部分都消耗在 <code class=\\\"language-text\\\">Header</code>上。从网上资料得知后来还有改进的轮询方法叫做 <code class=\\\"language-text\\\">Comet</code>，使用 <code class=\\\"language-text\\\">Ajax</code>。但这种技术虽然可达到双向通信，但依然需要发出请求，而且在 Comet 中，普遍采用了长链接，这也会大量消耗服务器带宽和资源。</p>\\n<p>所以 HTML5 定义了 <code class=\\\"language-text\\\">WebSocket</code> 协议，以及相关的编程 API，能更好的实现双向通信且节省服务器资源和带宽。</p>\\n<!-- more -->\\n<blockquote>\\n<p><strong>注意</strong>： <code class=\\\"language-text\\\">WebSocket</code> 实际上指的是一种协议，与我们熟知的 <code class=\\\"language-text\\\">Http</code> 协议是同等的一个网络协议。用网络模型结构来解释的话， <code class=\\\"language-text\\\">WebSocket</code> 和 <code class=\\\"language-text\\\">Http</code> 协议都属于 <code class=\\\"language-text\\\">应用层协议</code>，两者都基于传输层协议 <code class=\\\"language-text\\\">TCP</code>。</p>\\n</blockquote>\\n<h2 id=\\\"websocket-协议\\\"><a href=\\\"#websocket-%E5%8D%8F%E8%AE%AE\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>WebSocket 协议</h2>\\n<h3 id=\\\"与-html5-的联系\\\"><a href=\\\"#%E4%B8%8E-html5-%E7%9A%84%E8%81%94%E7%B3%BB\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>与 HTML5 的联系</h3>\\n<p>Html5 是指的一系列新的 API，或者说新规范，新技术。在这个新规范中定义了一个为了实现双向实时通信的新协议 <code class=\\\"language-text\\\">WebSocket</code>，并且提供了一套 JavaScript API 供开发者来调用实现通信。服务器端的实现由诸如：Tomcat、Jetty 等等。</p>\\n<h3 id=\\\"与-http-协议的联系\\\"><a href=\\\"#%E4%B8%8E-http-%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%81%94%E7%B3%BB\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>与 Http 协议的联系</h3>\\n<p>简单概括来看： <code class=\\\"language-text\\\">WebSocket</code> 不是 <code class=\\\"language-text\\\">Http</code> 协议， <code class=\\\"language-text\\\">Http</code> 协议只是被 <code class=\\\"language-text\\\">WebSocket</code> 使用来建立 <code class=\\\"language-text\\\">WebSocket</code> 连接，连接建立了以后客户端与服务器的双向通信就与 <code class=\\\"language-text\\\">Http</code> 无关了。</p>\\n<p><code class=\\\"language-text\\\">WebSocket</code> 协议和 <code class=\\\"language-text\\\">HTTP</code> 协议是两种不同的东西，它们的联系如下：</p>\\n<blockquote>\\n<p>客户端开始建立 WebSocket 连接时要发送一个 header 标记了 Upgrade 的 HTTP 请求，表示请求协议升级。所以服务器端做出响应的简便方法是，直接在现有的 HTTP 服务器软件和现有的端口上实现 WebSocket 协议，重用现有代码（比如解析和认证这个 HTTP 请求。如果在 TCP 协议上实现，这两个功能就要重新实现），然后再回一个状态码为 101 的 HTTP 响应完成握手，再往后发送数据时就没 HTTP 的事了。</p>\\n</blockquote>\\n<blockquote>\\n<p>作者：长天之云链接：<a href=\\\"https://www.zhihu.com/question/20215561/answer/14365823\\\">https://www.zhihu.com/question/20215561/answer/14365823</a>\\n来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处.</p>\\n</blockquote>\\n<h3 id=\\\"例子\\\"><a href=\\\"#%E4%BE%8B%E5%AD%90\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>例子</h3>\\n<p>下面给出发出建立连接请求时的 <code class=\\\"language-text\\\">request</code> 和 <code class=\\\"language-text\\\">response</code>。</p>\\n<p><strong>注意：下面的请求报文与响应报文中的内容不是完整的报文，而是 <code class=\\\"language-text\\\">WebSocket</code> 基于 <code class=\\\"language-text\\\">Http</code> 请求（响应）报文添加的内容。</strong></p>\\n<p>浏览器请求</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-html\\\"><code class=\\\"language-html\\\">GET / HTTP/1.1\\nUpgrade: websocket\\nConnection: Upgrade\\nHost: example.com\\nOrigin: null\\nSec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==\\nSec-WebSocket-Version: 13\\n</code></pre>\\n      </div>\\n<p>服务器回应</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-html\\\"><code class=\\\"language-html\\\">HTTP/1.1 101 Switching Protocols\\nUpgrade: websocket\\nConnection: Upgrade\\nSec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=\\nSec-WebSocket-Origin: null\\nSec-WebSocket-Location: ws://example.com/\\n</code></pre>\\n      </div>\",\"frontmatter\":{\"title\":\"WebSocket 原理\",\"date\":\"May 12, 2016\"}}},\"pathContext\":{\"slug\":\"/websocket-theory/\",\"previous\":{\"fields\":{\"slug\":\"/webuploader-usage-review/\"},\"frontmatter\":{\"title\":\"使用 WebUploader 解决安卓微信浏览器上传图片中遇到的 bug\"}},\"next\":{\"fields\":{\"slug\":\"/atom-custom-style/\"},\"frontmatter\":{\"title\":\"自定义Atom编辑器的样式\"}}}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---websocket-theory-1333c00be365a4ff1dc4.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Blog - Jianhua Cheng\",\"author\":\"Jianhua Cheng\"}},\"markdownRemark\":{\"id\":\"/Users/chengjianhua/Documents/codes/chengjianhua.github.io/src/pages/websocket-theory/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<h2 id=\\\"背景\\\"><a href=\\\"#%E8%83%8C%E6%99%AF\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>背景</h2>\\n<p>以前的网站为了实现<strong>推送</strong>功能，使用的方法都是<strong>轮询</strong>。所谓的轮询就是在特定的时间间隔（例如 1 秒），由浏览器向服务器发出一个 <code class=\\\"language-text\\\">Http request</code>，然后服务器返回最新的数据给客户端浏览器，从而给出一种服务端实时推送的假象。由于<code class=\\\"language-text\\\">Http Request</code>的<code class=\\\"language-text\\\">Header</code>（请求头）很长,而传输的数据可能很短就只占一点点，每次请求消耗的带宽大部分都消耗在 <code class=\\\"language-text\\\">Header</code>上。从网上资料得知后来还有改进的轮询方法叫做 <code class=\\\"language-text\\\">Comet</code>，使用 <code class=\\\"language-text\\\">Ajax</code>。但这种技术虽然可达到双向通信，但依然需要发出请求，而且在 Comet 中，普遍采用了长链接，这也会大量消耗服务器带宽和资源。</p>\\n<p>所以 HTML5 定义了 <code class=\\\"language-text\\\">WebSocket</code> 协议，以及相关的编程 API，能更好的实现双向通信且节省服务器资源和带宽。</p>\\n<!-- more -->\\n<blockquote>\\n<p><strong>注意</strong>： <code class=\\\"language-text\\\">WebSocket</code> 实际上指的是一种协议，与我们熟知的 <code class=\\\"language-text\\\">Http</code> 协议是同等的一个网络协议。用网络模型结构来解释的话， <code class=\\\"language-text\\\">WebSocket</code> 和 <code class=\\\"language-text\\\">Http</code> 协议都属于 <code class=\\\"language-text\\\">应用层协议</code>，两者都基于传输层协议 <code class=\\\"language-text\\\">TCP</code>。</p>\\n</blockquote>\\n<h2 id=\\\"websocket-协议\\\"><a href=\\\"#websocket-%E5%8D%8F%E8%AE%AE\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>WebSocket 协议</h2>\\n<h3 id=\\\"与-html5-的联系\\\"><a href=\\\"#%E4%B8%8E-html5-%E7%9A%84%E8%81%94%E7%B3%BB\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>与 HTML5 的联系</h3>\\n<p>Html5 是指的一系列新的 API，或者说新规范，新技术。在这个新规范中定义了一个为了实现双向实时通信的新协议 <code class=\\\"language-text\\\">WebSocket</code>，并且提供了一套 JavaScript API 供开发者来调用实现通信。服务器端的实现由诸如：Tomcat、Jetty 等等。</p>\\n<h3 id=\\\"与-http-协议的联系\\\"><a href=\\\"#%E4%B8%8E-http-%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%81%94%E7%B3%BB\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>与 Http 协议的联系</h3>\\n<p>简单概括来看： <code class=\\\"language-text\\\">WebSocket</code> 不是 <code class=\\\"language-text\\\">Http</code> 协议， <code class=\\\"language-text\\\">Http</code> 协议只是被 <code class=\\\"language-text\\\">WebSocket</code> 使用来建立 <code class=\\\"language-text\\\">WebSocket</code> 连接，连接建立了以后客户端与服务器的双向通信就与 <code class=\\\"language-text\\\">Http</code> 无关了。</p>\\n<p><code class=\\\"language-text\\\">WebSocket</code> 协议和 <code class=\\\"language-text\\\">HTTP</code> 协议是两种不同的东西，它们的联系如下：</p>\\n<blockquote>\\n<p>客户端开始建立 WebSocket 连接时要发送一个 header 标记了 Upgrade 的 HTTP 请求，表示请求协议升级。所以服务器端做出响应的简便方法是，直接在现有的 HTTP 服务器软件和现有的端口上实现 WebSocket 协议，重用现有代码（比如解析和认证这个 HTTP 请求。如果在 TCP 协议上实现，这两个功能就要重新实现），然后再回一个状态码为 101 的 HTTP 响应完成握手，再往后发送数据时就没 HTTP 的事了。</p>\\n</blockquote>\\n<blockquote>\\n<p>作者：长天之云链接：<a href=\\\"https://www.zhihu.com/question/20215561/answer/14365823\\\">https://www.zhihu.com/question/20215561/answer/14365823</a>\\n来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处.</p>\\n</blockquote>\\n<h3 id=\\\"例子\\\"><a href=\\\"#%E4%BE%8B%E5%AD%90\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>例子</h3>\\n<p>下面给出发出建立连接请求时的 <code class=\\\"language-text\\\">request</code> 和 <code class=\\\"language-text\\\">response</code>。</p>\\n<p><strong>注意：下面的请求报文与响应报文中的内容不是完整的报文，而是 <code class=\\\"language-text\\\">WebSocket</code> 基于 <code class=\\\"language-text\\\">Http</code> 请求（响应）报文添加的内容。</strong></p>\\n<p>浏览器请求</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-html\\\"><code class=\\\"language-html\\\">GET / HTTP/1.1\\nUpgrade: websocket\\nConnection: Upgrade\\nHost: example.com\\nOrigin: null\\nSec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==\\nSec-WebSocket-Version: 13\\n</code></pre>\\n      </div>\\n<p>服务器回应</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-html\\\"><code class=\\\"language-html\\\">HTTP/1.1 101 Switching Protocols\\nUpgrade: websocket\\nConnection: Upgrade\\nSec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=\\nSec-WebSocket-Origin: null\\nSec-WebSocket-Location: ws://example.com/\\n</code></pre>\\n      </div>\",\"frontmatter\":{\"title\":\"WebSocket 原理\",\"date\":\"May 12, 2016\"}}},\"pathContext\":{\"slug\":\"/websocket-theory/\",\"previous\":{\"fields\":{\"slug\":\"/webuploader-usage-review/\"},\"frontmatter\":{\"title\":\"使用 WebUploader 解决安卓微信浏览器上传图片中遇到的 bug\"}},\"next\":{\"fields\":{\"slug\":\"/atom-custom-style/\"},\"frontmatter\":{\"title\":\"自定义Atom编辑器的样式\"}}}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/websocket-theory.json\n// module id = 556\n// module chunks = 8617267641406"],"sourceRoot":""}