{"version":3,"sources":["webpack:///path---websocket-theory-4858dc3ef4bfbf4cfae1.js","webpack:///./.cache/json/websocket-theory.json"],"names":["webpackJsonp","541","module","exports","data","site","siteMetadata","title","author","markdownRemark","id","html","frontmatter","date","pathContext","slug","previous","fields","next"],"mappings":"AAAAA,cAAc,gBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,uBAAAC,OAAA,kBAAyDC,gBAAmBC,GAAA,oIAAAC,KAAA,kjGAAAC,aAAmxGL,MAAA,eAAAM,KAAA,kBAA+CC,aAAgBC,KAAA,qBAAAC,UAAwCC,QAAUF,KAAA,8BAAoCH,aAAgBL,MAAA,sCAA6CW,MAASD,QAAUF,KAAA,uBAA6BH,aAAgBL,MAAA","file":"path---websocket-theory-4858dc3ef4bfbf4cfae1.js","sourcesContent":["webpackJsonp([8617267641406],{\n\n/***/ 541:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Blog - Jianhua Cheng\",\"author\":\"Jianhua Cheng\"}},\"markdownRemark\":{\"id\":\"/Users/chengjianhua/Documents/codes/chengjianhua.github.io/src/pages/websocket-theory/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>WebSocket 原理</h1>\\n<h2>背景</h2>\\n<p>以前的网站为了实现<strong>推送</strong>功能，使用的方法都是<strong>轮询</strong>。所谓的轮询就是在特定的时间间隔（例如1秒），由浏览器向服务器发出一个 <code class=\\\"language-text\\\">Http request</code>，然后服务器返回最新的数据给客户端浏览器，从而给出一种服务端实时推送的假象。由于<code class=\\\"language-text\\\">Http Request</code>的<code class=\\\"language-text\\\">Header</code>（请求头）很长,而传输的数据可能很短就只占一点点，每次请求消耗的带宽大部分都消耗在 <code class=\\\"language-text\\\">Header</code>上。从网上资料得知后来还有改进的轮询方法叫做 <code class=\\\"language-text\\\">Comet</code>，使用 <code class=\\\"language-text\\\">Ajax</code>。但这种技术虽然可达到双向通信，但依然需要发出请求，而且在Comet中，普遍采用了长链接，这也会大量消耗服务器带宽和资源。</p>\\n<p>所以HTML5定义了 <code class=\\\"language-text\\\">WebSocket</code> 协议，以及相关的编程API，能更好的实现双向通信且节省服务器资源和带宽。</p>\\n<!-- more -->\\n<blockquote>\\n<p><strong>注意</strong>： <code class=\\\"language-text\\\">WebSocket</code> 实际上指的是一种协议，与我们熟知的 <code class=\\\"language-text\\\">Http</code> 协议是同等的一个网络协议。用网络模型结构来解释的话， <code class=\\\"language-text\\\">WebSocket</code> 和 <code class=\\\"language-text\\\">Http</code> 协议都属于 <code class=\\\"language-text\\\">应用层协议</code>，两者都基于传输层协议 <code class=\\\"language-text\\\">TCP</code>。</p>\\n</blockquote>\\n<h2>WebSocket 协议</h2>\\n<h3>与HTML5的联系</h3>\\n<p>Html5是指的一系列新的API，或者说新规范，新技术。在这个新规范中定义了一个为了实现双向实时通信的新协议 <code class=\\\"language-text\\\">WebSocket</code>，并且提供了一套 JavaScript API 供开发者来调用实现通信。服务器端的实现由诸如：Tomcat、Jetty等等。</p>\\n<h3>与Http协议的联系</h3>\\n<p>简单概括来看： <code class=\\\"language-text\\\">WebSocket</code> 不是 <code class=\\\"language-text\\\">Http</code> 协议， <code class=\\\"language-text\\\">Http</code> 协议只是被 <code class=\\\"language-text\\\">WebSocket</code> 使用来建立 <code class=\\\"language-text\\\">WebSocket</code> 连接，连接建立了以后客户端与服务器的双向通信就与 <code class=\\\"language-text\\\">Http</code> 无关了。</p>\\n<p><code class=\\\"language-text\\\">WebSocket</code> 协议和 <code class=\\\"language-text\\\">HTTP</code> 协议是两种不同的东西，它们的联系如下：</p>\\n<blockquote>\\n<p>客户端开始建立 WebSocket 连接时要发送一个 header 标记了 Upgrade 的 HTTP 请求，表示请求协议升级。\\n所以服务器端做出响应的简便方法是，直接在现有的 HTTP 服务器软件和现有的端口上实现 WebSocket 协议，重用现有代码（比如解析和认证这个 HTTP 请求。如果在 TCP 协议上实现，这两个功能就要重新实现），然后再回一个状态码为 101 的 HTTP 响应完成握手，再往后发送数据时就没 HTTP 的事了。</p>\\n</blockquote>\\n<blockquote>\\n<p>作者：长天之云\\n链接：<a href=\\\"https://www.zhihu.com/question/20215561/answer/14365823\\\">https://www.zhihu.com/question/20215561/answer/14365823</a>\\n来源：知乎\\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处.</p>\\n</blockquote>\\n<h3>例子</h3>\\n<p>下面给出发出建立连接请求时的 <code class=\\\"language-text\\\">request</code> 和 <code class=\\\"language-text\\\">response</code>。</p>\\n<p><strong>注意：下面的请求报文与响应报文中的内容不是完整的报文，而是 <code class=\\\"language-text\\\">WebSocket</code> 基于 <code class=\\\"language-text\\\">Http</code> 请求（响应）报文添加的内容。</strong></p>\\n<p>浏览器请求</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-html\\\"><code class=\\\"language-html\\\">GET / HTTP/1.1\\nUpgrade: websocket\\nConnection: Upgrade\\nHost: example.com\\nOrigin: null\\nSec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==\\nSec-WebSocket-Version: 13\\n</code></pre>\\n      </div>\\n<p>服务器回应</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-html\\\"><code class=\\\"language-html\\\">HTTP/1.1 101 Switching Protocols\\nUpgrade: websocket\\nConnection: Upgrade\\nSec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=\\nSec-WebSocket-Origin: null\\nSec-WebSocket-Location: ws://example.com/\\n</code></pre>\\n      </div>\",\"frontmatter\":{\"title\":\"WebSocket 原理\",\"date\":\"May 12, 2016\"}}},\"pathContext\":{\"slug\":\"/websocket-theory/\",\"previous\":{\"fields\":{\"slug\":\"/webuploader-usage-review/\"},\"frontmatter\":{\"title\":\"使用WebUploader解决安卓微信浏览器上传图片中遇到的bug\"}},\"next\":{\"fields\":{\"slug\":\"/atom-custom-style/\"},\"frontmatter\":{\"title\":\"自定义Atom编辑器的样式\"}}}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---websocket-theory-4858dc3ef4bfbf4cfae1.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Blog - Jianhua Cheng\",\"author\":\"Jianhua Cheng\"}},\"markdownRemark\":{\"id\":\"/Users/chengjianhua/Documents/codes/chengjianhua.github.io/src/pages/websocket-theory/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>WebSocket 原理</h1>\\n<h2>背景</h2>\\n<p>以前的网站为了实现<strong>推送</strong>功能，使用的方法都是<strong>轮询</strong>。所谓的轮询就是在特定的时间间隔（例如1秒），由浏览器向服务器发出一个 <code class=\\\"language-text\\\">Http request</code>，然后服务器返回最新的数据给客户端浏览器，从而给出一种服务端实时推送的假象。由于<code class=\\\"language-text\\\">Http Request</code>的<code class=\\\"language-text\\\">Header</code>（请求头）很长,而传输的数据可能很短就只占一点点，每次请求消耗的带宽大部分都消耗在 <code class=\\\"language-text\\\">Header</code>上。从网上资料得知后来还有改进的轮询方法叫做 <code class=\\\"language-text\\\">Comet</code>，使用 <code class=\\\"language-text\\\">Ajax</code>。但这种技术虽然可达到双向通信，但依然需要发出请求，而且在Comet中，普遍采用了长链接，这也会大量消耗服务器带宽和资源。</p>\\n<p>所以HTML5定义了 <code class=\\\"language-text\\\">WebSocket</code> 协议，以及相关的编程API，能更好的实现双向通信且节省服务器资源和带宽。</p>\\n<!-- more -->\\n<blockquote>\\n<p><strong>注意</strong>： <code class=\\\"language-text\\\">WebSocket</code> 实际上指的是一种协议，与我们熟知的 <code class=\\\"language-text\\\">Http</code> 协议是同等的一个网络协议。用网络模型结构来解释的话， <code class=\\\"language-text\\\">WebSocket</code> 和 <code class=\\\"language-text\\\">Http</code> 协议都属于 <code class=\\\"language-text\\\">应用层协议</code>，两者都基于传输层协议 <code class=\\\"language-text\\\">TCP</code>。</p>\\n</blockquote>\\n<h2>WebSocket 协议</h2>\\n<h3>与HTML5的联系</h3>\\n<p>Html5是指的一系列新的API，或者说新规范，新技术。在这个新规范中定义了一个为了实现双向实时通信的新协议 <code class=\\\"language-text\\\">WebSocket</code>，并且提供了一套 JavaScript API 供开发者来调用实现通信。服务器端的实现由诸如：Tomcat、Jetty等等。</p>\\n<h3>与Http协议的联系</h3>\\n<p>简单概括来看： <code class=\\\"language-text\\\">WebSocket</code> 不是 <code class=\\\"language-text\\\">Http</code> 协议， <code class=\\\"language-text\\\">Http</code> 协议只是被 <code class=\\\"language-text\\\">WebSocket</code> 使用来建立 <code class=\\\"language-text\\\">WebSocket</code> 连接，连接建立了以后客户端与服务器的双向通信就与 <code class=\\\"language-text\\\">Http</code> 无关了。</p>\\n<p><code class=\\\"language-text\\\">WebSocket</code> 协议和 <code class=\\\"language-text\\\">HTTP</code> 协议是两种不同的东西，它们的联系如下：</p>\\n<blockquote>\\n<p>客户端开始建立 WebSocket 连接时要发送一个 header 标记了 Upgrade 的 HTTP 请求，表示请求协议升级。\\n所以服务器端做出响应的简便方法是，直接在现有的 HTTP 服务器软件和现有的端口上实现 WebSocket 协议，重用现有代码（比如解析和认证这个 HTTP 请求。如果在 TCP 协议上实现，这两个功能就要重新实现），然后再回一个状态码为 101 的 HTTP 响应完成握手，再往后发送数据时就没 HTTP 的事了。</p>\\n</blockquote>\\n<blockquote>\\n<p>作者：长天之云\\n链接：<a href=\\\"https://www.zhihu.com/question/20215561/answer/14365823\\\">https://www.zhihu.com/question/20215561/answer/14365823</a>\\n来源：知乎\\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处.</p>\\n</blockquote>\\n<h3>例子</h3>\\n<p>下面给出发出建立连接请求时的 <code class=\\\"language-text\\\">request</code> 和 <code class=\\\"language-text\\\">response</code>。</p>\\n<p><strong>注意：下面的请求报文与响应报文中的内容不是完整的报文，而是 <code class=\\\"language-text\\\">WebSocket</code> 基于 <code class=\\\"language-text\\\">Http</code> 请求（响应）报文添加的内容。</strong></p>\\n<p>浏览器请求</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-html\\\"><code class=\\\"language-html\\\">GET / HTTP/1.1\\nUpgrade: websocket\\nConnection: Upgrade\\nHost: example.com\\nOrigin: null\\nSec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==\\nSec-WebSocket-Version: 13\\n</code></pre>\\n      </div>\\n<p>服务器回应</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-html\\\"><code class=\\\"language-html\\\">HTTP/1.1 101 Switching Protocols\\nUpgrade: websocket\\nConnection: Upgrade\\nSec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=\\nSec-WebSocket-Origin: null\\nSec-WebSocket-Location: ws://example.com/\\n</code></pre>\\n      </div>\",\"frontmatter\":{\"title\":\"WebSocket 原理\",\"date\":\"May 12, 2016\"}}},\"pathContext\":{\"slug\":\"/websocket-theory/\",\"previous\":{\"fields\":{\"slug\":\"/webuploader-usage-review/\"},\"frontmatter\":{\"title\":\"使用WebUploader解决安卓微信浏览器上传图片中遇到的bug\"}},\"next\":{\"fields\":{\"slug\":\"/atom-custom-style/\"},\"frontmatter\":{\"title\":\"自定义Atom编辑器的样式\"}}}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/websocket-theory.json\n// module id = 541\n// module chunks = 8617267641406"],"sourceRoot":""}